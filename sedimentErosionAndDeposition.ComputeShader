#version 460 core
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, binding = 0) uniform image2D CD_image_output;

layout(rgba32f, binding = 1) uniform image2D W_image_output;

layout(rgba32f, binding = 2) uniform image2D CD_image;

layout(rgba32f, binding = 3) uniform image2D W_image;

layout(rgba32f, binding = 4) uniform image2D V_image;

float Height(vec4 column){
	return column.b + column.a;
}

float ErosionRamp(float d){
	float Kdmax = 0.0001f;
	float rampScale;
	
	if(d <= 0){
		rampScale = 0;
	}
	else if(d >= Kdmax){
		rampScale = 1;
	}
	else{
		rampScale = 1 - ((Kdmax - d) / Kdmax);
	}

	return rampScale;
}

float SedimentValue(vec4 waterData){
	return waterData.r + waterData.g;
}

void main()
{    
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	vec2 imageSize = imageSize(CD_image_output);
    ivec2 deltaX = ivec2(1, 0);
	ivec2 deltaY = ivec2(0, 1);

	vec4 centerColumn = imageLoad(CD_image, pixelCoords);
	vec4 centerWater = imageLoad(W_image, pixelCoords);
	vec4 centerVelocity = imageLoad(V_image, pixelCoords);

	vec4 leftColumn = imageLoad(CD_image, pixelCoords - deltaX);
	vec4 rightColumn = imageLoad(CD_image, pixelCoords + deltaX);
	vec4 topColumn = imageLoad(CD_image, pixelCoords + deltaY);
	vec4 bottomColumn = imageLoad(CD_image, pixelCoords - deltaY);

	// Sediment Capacity constant
	float Kc = 0.003f;
	// Dissolving constant
	float Ks = 0.001f * max(0, (1.0f - 2.0f * max(0, centerWater.a)));
	// Deposition constant
	float Kd = 0.001f;

	float newWaterHeight;
	float newTerrainHeight;
	float newDeadPlantValue;
	float newSedimentValue;
	float newDeadPlantSedimentValue;
	float localTiltAngle;

	// Calculate normal of vector for current point
	vec3 normal;
	vec2 texelSize = vec2(1.0f / imageSize.x, 1.0f / imageSize.y);

	float leftHeight = Height(leftColumn);
	float rightHeight = Height(rightColumn);
	float topHeight = Height(topColumn);
	float bottomHeight = Height(bottomColumn);

	normal = vec3(leftHeight - rightHeight, 2 * texelSize.x, bottomHeight - topHeight);
	normal = normalize(normal);

	vec3 flatNormal = normalize(vec3(0.0f, 1.0f, 0.0f));

	// Dot product between vertical normal and calculated normal vectors
	// Should be a value between -1 and 1, otherwise acos is undefined for it
	localTiltAngle = acos(dot(flatNormal, normal));

	float sedimentCapacity = Kc * sin(localTiltAngle) * length(centerVelocity.rg) * ErosionRamp(centerColumn.r);

	// If sediment capacity of water is greater than current amount of sediment dissolved into water
	// dissolve some more terrain into the water and adjust terrain height and sediment value accordingly
	float sedimentChangeAmount;
	if(sedimentCapacity > SedimentValue(centerWater)){
		sedimentChangeAmount = Ks * (sedimentCapacity - SedimentValue(centerWater));
		newWaterHeight = centerColumn.r + sedimentChangeAmount;

		if(centerColumn.g >= (sedimentChangeAmount / 2)){
			newDeadPlantValue = centerColumn.g - (sedimentChangeAmount / 2);
			newTerrainHeight = centerColumn.a - (sedimentChangeAmount / 2);
			newSedimentValue = centerWater.r + (sedimentChangeAmount / 2);
			newDeadPlantSedimentValue = centerWater.g + (sedimentChangeAmount / 2);
		}
		else{
			newDeadPlantValue = 0;
			newTerrainHeight = centerColumn.a - (sedimentChangeAmount - centerColumn.g);
			newSedimentValue = centerWater.r + (sedimentChangeAmount - centerColumn.g);
			newDeadPlantSedimentValue = centerWater.g + centerColumn.g;
		}
	}
	// If sediment capacity of water is not greater than current amount of sediment dissolved into water
	// release some sediment back into the terrain and adjust terrain height and sediment value accordingly
	else{
		sedimentChangeAmount = Kd * (SedimentValue(centerWater) - sedimentCapacity);
		newWaterHeight = centerColumn.r - sedimentChangeAmount;

		if(centerWater.g >= (sedimentChangeAmount / 2)){
			newDeadPlantValue = centerColumn.g + (sedimentChangeAmount / 2);
			newTerrainHeight = centerColumn.a + (sedimentChangeAmount / 2);
			newSedimentValue = centerWater.r - (sedimentChangeAmount / 2);
			newDeadPlantSedimentValue = centerWater.g - (sedimentChangeAmount / 2);
		}
		else{
			newDeadPlantValue = centerWater.g;
			newTerrainHeight = centerColumn.a + (sedimentChangeAmount - centerColumn.g);
			newSedimentValue = centerWater.r - (sedimentChangeAmount - centerColumn.g);
			newDeadPlantSedimentValue = 0;
		}
	}

	imageStore(CD_image_output, pixelCoords, vec4(newWaterHeight, newDeadPlantValue, centerColumn.b, newTerrainHeight));
	imageStore(W_image_output, pixelCoords, vec4(newSedimentValue, newDeadPlantSedimentValue, centerWater.b, centerWater.a));
}