#version 460 core
layout(local_size_x = 1, local_size_y = 1) in;

layout(rgba32f, binding = 0) uniform image2D image_output;

layout(rgba32f, binding = 1) uniform image2D CD_image;

struct Source{
	ivec2 position;
	int radius;

	// Increment Constant
	float Kis;
};

struct Raindrop{
	ivec2 position;
	int radius;

	// Increment Constant
	float Kir;
};

#define MAX_NUMBER_SOURCES 4
#define MAX_NUMBER_RAINDROPS 4

uniform bool isSourceFlow;
uniform int currentNumberSources;
uniform Source sources[MAX_NUMBER_SOURCES];

uniform bool isRain;
uniform int currentNumberRaindrops;
uniform Raindrop raindrops[MAX_NUMBER_RAINDROPS];

uniform float timeStep;

bool withinSourceRadius(int sourceX, int sourceY, int sourceRadius, int x, int y){
	int differenceX = sourceX - x;
	int differenceY = sourceY - y;

	return (sourceRadius * sourceRadius) >= (differenceX * differenceX + differenceY * differenceY);
}

void main()
{    
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	vec2 imageSize = imageSize(image_output);
    
	vec4 columnData = imageLoad(CD_image, pixelCoords);

	float newWaterHeight = 0;
	float sourceIncrementValue = 0;
	float rainIncrementValue = 0;

	// Sources
	if(isSourceFlow){
		for(int i = 0; i < currentNumberSources; i++){
			if(withinSourceRadius(sources[i].position.x, sources[i].position.y, sources[i].radius, pixelCoords.x, pixelCoords.y)){
				sourceIncrementValue += sources[i].Kis * timeStep;
			}
		}		
	}

	// Rain
	if(isRain){
		for(int i = 0; i < currentNumberRaindrops; i++){
			if(withinSourceRadius(raindrops[i].position.x, raindrops[i].position.y, raindrops[i].radius, pixelCoords.x, pixelCoords.y)){
				rainIncrementValue += raindrops[i].Kir * timeStep;
			}
		}
	}

	newWaterHeight = columnData.r + sourceIncrementValue + rainIncrementValue;

	imageStore(image_output, pixelCoords, vec4(newWaterHeight, columnData.g, columnData.b, columnData.a));
}