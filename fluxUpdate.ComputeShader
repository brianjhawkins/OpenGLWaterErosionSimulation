#version 460 core
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, binding = 0) uniform image2D F_image_output;

layout(rgba32f, binding = 1) uniform image2D R_image_output;

layout(rgba32f, binding = 2) uniform image2D CD_image;

layout(rgba32f, binding = 3) uniform image2D F_image;

layout(rgba32f, binding = 4) uniform image2D R_image;

uniform float timeStep;

float waterHeight(vec4 v){
	return v.r + v.b + v.a;
}

float regolithHeight(vec4 v){
	return v.b + v.a;
}

float waterHeightDifference(vec4 center, vec4 adjacent){
	return waterHeight(center) - waterHeight(adjacent);
}

float regolithHeightDifference(vec4 center, vec4 adjacent){
	return regolithHeight(center) - regolithHeight(adjacent);
}

void main()
{    
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	vec2 imageSize = imageSize(F_image_output);
    ivec2 deltaX = ivec2(1, 0);
	ivec2 deltaY = ivec2(0, 1);

	vec4 centerColumn = imageLoad(CD_image, pixelCoords);
	vec4 centerWaterFlux = imageLoad(F_image, pixelCoords);
	vec4 centerRegolithFlux = imageLoad(R_image, pixelCoords);

	vec4 leftColumn = imageLoad(CD_image, pixelCoords - deltaX);
	vec4 rightColumn = imageLoad(CD_image, pixelCoords + deltaX);
	vec4 topColumn = imageLoad(CD_image, pixelCoords + deltaY);
	vec4 bottomColumn = imageLoad(CD_image, pixelCoords - deltaY);

	// Water flux values
	float leftWaterFlux = 0;
	float rightWaterFlux = 0;
	float topWaterFlux = 0;
	float bottomWaterFlux = 0;

	// Regolith flux values
	float leftRegolithFlux = 0;
	float rightRegolithFlux = 0;
	float topRegolithFlux = 0;
	float bottomRegolithFlux = 0;

	float K;

	float l = 1 / imageSize.x;
	float A = l * l;
	float g = imageSize.x / 2;
	float wKf = 0.999f;
	//wKf = 1;
	float rKf = 0.3f;
	//rKf = 0;
	
	// Left Flux
	if(pixelCoords.x != 0){
		leftWaterFlux = max(0, wKf * centerWaterFlux.r + (timeStep * A * (g * waterHeightDifference(centerColumn, leftColumn) / l)));
		leftRegolithFlux = max(0, rKf * centerRegolithFlux.r + (timeStep * A * (g * regolithHeightDifference(centerColumn, leftColumn) / l)));
	}

	// Right Flux
	if(pixelCoords.x != imageSize.x - 1){
		rightWaterFlux = max(0, wKf * centerWaterFlux.g + (timeStep * A * (g * waterHeightDifference(centerColumn, rightColumn) / l)));
		rightRegolithFlux = max(0, rKf * centerRegolithFlux.g + (timeStep * A * (g * regolithHeightDifference(centerColumn, rightColumn) / l)));
	}

	// Top Flux
	if(pixelCoords.y != imageSize.y - 1){
		topWaterFlux = max(0, wKf * centerWaterFlux.b + (timeStep * A * (g * waterHeightDifference(centerColumn, topColumn) / l)));
		topRegolithFlux = max(0, rKf * centerRegolithFlux.b + (timeStep * A * (g * regolithHeightDifference(centerColumn, topColumn) / l)));
	}

	// Bottom Flux
	if(pixelCoords.y != 0){
		bottomWaterFlux = max(0, wKf * centerWaterFlux.a + (timeStep * A * (g * waterHeightDifference(centerColumn, bottomColumn) / l)));
		bottomRegolithFlux = max(0, rKf * centerRegolithFlux.a + (timeStep * A * (g * regolithHeightDifference(centerColumn, bottomColumn) / l)));
	}

	// Scaling Factor K
	if((leftWaterFlux != 0 || rightWaterFlux != 0 || topWaterFlux != 0 || bottomWaterFlux != 0) && centerColumn.r != 0){
		K = min(1, (centerColumn.r * l * l) / ((leftWaterFlux + rightWaterFlux + topWaterFlux + bottomWaterFlux) * timeStep));
	}
	else{
		K = 0;
	}

	// Scale each water flux by K
	leftWaterFlux *= K;
	rightWaterFlux *= K;
	topWaterFlux *= K;
	bottomWaterFlux *= K;

	// Scaling Factor K
	if((leftRegolithFlux != 0 || rightRegolithFlux != 0 || topRegolithFlux != 0 || bottomRegolithFlux != 0) && centerColumn.b != 0){
		K = min(1, (centerColumn.b * l * l) / ((leftRegolithFlux + rightRegolithFlux + topRegolithFlux + bottomRegolithFlux) * timeStep));
	}
	else{
		K = 0;
	}

	// Scale each regolith flux by K
	leftRegolithFlux *= K;
	rightRegolithFlux *= K;
	topRegolithFlux *= K;
	bottomRegolithFlux *= K;

	imageStore(F_image_output, pixelCoords, vec4(leftWaterFlux, rightWaterFlux, topWaterFlux, bottomWaterFlux));
	imageStore(R_image_output, pixelCoords, vec4(leftRegolithFlux, rightRegolithFlux, topRegolithFlux, bottomRegolithFlux));
}