#version 460 core
layout(local_size_x = 32, local_size_y = 32) in;

layout(rgba32f, binding = 0) uniform image2D S_image_output;

layout(rgba32f, binding = 1) uniform image2D SC_image_output;

layout(rgba32f, binding = 2) uniform image2D CD_image;

layout(rgba32f, binding = 3) uniform image2D W_image;

uniform bool isSoilFlow;
uniform float talusHeightDiff;
uniform float Kt;
uniform float pipeLength;
uniform float width;
uniform float height;
uniform float timeStep;

float Height(vec4 c, vec4 w){
	return c.g + w.a + c.b + c.a;
}

float HeightDifference(float centerHeight, float adjacentHeight){
	return max(0, centerHeight - adjacentHeight);
}

float HeightDifference(vec4 centerColumnData, vec4 centerWater, vec4 adjacentColumn, vec4 adjacentWater){
	return HeightDifference(Height(centerColumnData, centerWater), Height(adjacentColumn, adjacentWater));
}

void main()
{   
	ivec2 pixelCoords = ivec2(gl_GlobalInvocationID.xy);

	float newLeftValue = 0;
	float newRightValue = 0;
	float newTopValue = 0;
	float newBottomValue = 0;
	
	float newBottomLeftValue = 0;
	float newBottomRightValue = 0;
	float newTopLeftValue = 0;
	float newTopRightValue = 0;

	if(isSoilFlow){
		ivec2 deltaX = ivec2(1, 0);
		ivec2 deltaY = ivec2(0, 1);

		vec4 centerColumnData = imageLoad(CD_image, pixelCoords);
		vec4 centerWaterData = imageLoad(W_image, pixelCoords);

		float centerHeight = Height(centerColumnData, centerWaterData);

		vec4 leftColumnData = imageLoad(CD_image, pixelCoords - deltaX);
		vec4 leftWaterData = imageLoad(W_image, pixelCoords - deltaX);
		vec4 rightColumnData = imageLoad(CD_image, pixelCoords + deltaX);
		vec4 rightWaterData = imageLoad(W_image, pixelCoords + deltaX);
		vec4 topColumnData = imageLoad(CD_image, pixelCoords + deltaY);
		vec4 topWaterData = imageLoad(W_image, pixelCoords + deltaY);
		vec4 bottomColumnData = imageLoad(CD_image, pixelCoords - deltaY);
		vec4 bottomWaterData = imageLoad(W_image, pixelCoords - deltaY);

		float leftHeight = Height(leftColumnData, leftWaterData);
		float rightHeight = Height(rightColumnData, rightWaterData);
		float topHeight = Height(topColumnData, topWaterData);
		float bottomHeight = Height(bottomColumnData, bottomWaterData);
	
		vec4 bottomLeftColumnData = imageLoad(CD_image, pixelCoords - deltaX - deltaY);
		vec4 bottomLeftWaterData = imageLoad(W_image, pixelCoords - deltaX - deltaY);
		vec4 bottomRightColumnData = imageLoad(CD_image, pixelCoords + deltaX - deltaY);
		vec4 bottomRightWaterData = imageLoad(W_image, pixelCoords + deltaX - deltaY);
		vec4 topLeftColumnData = imageLoad(CD_image, pixelCoords - deltaX + deltaY);
		vec4 topLeftWaterData = imageLoad(W_image, pixelCoords - deltaX + deltaY);
		vec4 topRightColumnData = imageLoad(CD_image, pixelCoords + deltaX + deltaY);
		vec4 topRightWaterData = imageLoad(W_image, pixelCoords + deltaX + deltaY);

		float bottomLeftHeight = Height(bottomLeftColumnData, bottomLeftWaterData);
		float bottomRightHeight = Height(bottomRightColumnData, bottomRightWaterData);
		float topLeftHeight = Height(topLeftColumnData, topLeftWaterData);
		float topRightHeight = Height(topRightColumnData, topRightWaterData);

		float maxHeightDifference = 0;
		float A = 0;

		// Left
		if(pixelCoords.x != 0 && HeightDifference(centerHeight, leftHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, leftHeight));
			A += HeightDifference(centerHeight, leftHeight);
			newLeftValue = HeightDifference(centerHeight, leftHeight);
		}

		// Right
		if(pixelCoords.x != width - 1 && HeightDifference(centerHeight, rightHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, rightHeight));
			A += HeightDifference(centerHeight, rightHeight);
			newRightValue = HeightDifference(centerHeight, rightHeight);
		}

		// Top
		if(pixelCoords.y != height - 1 && HeightDifference(centerHeight, topHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, topHeight));
			A += HeightDifference(centerHeight, topHeight);
			newTopValue = HeightDifference(centerHeight, topHeight);
		}

		// Bottom
		if(pixelCoords.y != 0 && HeightDifference(centerHeight, bottomHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, bottomHeight));
			A += HeightDifference(centerHeight, bottomHeight);
			newBottomValue = HeightDifference(centerHeight, bottomHeight);
		}

		// Bottom Left
		if(pixelCoords.x != 0 && pixelCoords.y != 0 && HeightDifference(centerHeight, bottomLeftHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, bottomLeftHeight));
			A += HeightDifference(centerHeight, bottomLeftHeight);
			newBottomLeftValue = HeightDifference(centerHeight, bottomLeftHeight);
		}

		// Bottom Right
		if(pixelCoords.x != width - 1 && pixelCoords.y != 0 && HeightDifference(centerHeight, bottomRightHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, bottomRightHeight));
			A += HeightDifference(centerHeight, bottomRightHeight);
			newBottomRightValue = HeightDifference(centerHeight, bottomRightHeight);
		}

		// Top Left
		if(pixelCoords.x != 0 && pixelCoords.y != height - 1 && HeightDifference(centerHeight, topLeftHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, topLeftHeight));
			A += HeightDifference(centerHeight, topLeftHeight);
			newTopLeftValue = HeightDifference(centerHeight, topLeftHeight);
		}

		// Top Right
		if(pixelCoords.x != width - 1 && pixelCoords.y != height - 1 && HeightDifference(centerHeight, topRightHeight) > talusHeightDiff){
			maxHeightDifference = max(maxHeightDifference, HeightDifference(centerHeight, topRightHeight));
			A += HeightDifference(centerHeight, topRightHeight);
			newTopRightValue = HeightDifference(centerHeight, topRightHeight);
		}

		float columnArea = pipeLength * pipeLength;
		columnArea = 1;

		float sedimentVolume = columnArea * timeStep * Kt * (maxHeightDifference / 2);

		if(A != 0){
			newLeftValue *= sedimentVolume / A;
			newRightValue *= sedimentVolume / A;
			newTopValue *= sedimentVolume / A;
			newBottomValue *= sedimentVolume / A;
			newBottomLeftValue *= sedimentVolume / A;
			newBottomRightValue *= sedimentVolume / A;
			newTopLeftValue *= sedimentVolume / A;
			newTopRightValue *= sedimentVolume / A;
		}
	}

	imageStore(S_image_output, pixelCoords, vec4(newLeftValue, newRightValue, newTopValue, newBottomValue));
	imageStore(SC_image_output, pixelCoords, vec4(newBottomLeftValue, newBottomRightValue, newTopLeftValue, newTopRightValue));
}